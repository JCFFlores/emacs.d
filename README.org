* Introduction to awesome JCFFlores Emacs config
The purpose of this emacs config file is to learn more about emacs lisp
and the internals of emacs, as well as to leverage the opportunity to toy
a little bit with literate programming.
* Initial setup
** Package configuration
*** Require package.el before continuing
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC
*** Add archives
The melpa archive is required to install most packages, the org archive
is required to install org-plus-contrib package later on
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
#+END_SRC
** Custom configuration
Set the custom-file variable, check if the custom file already exists
and then load it. This should prevent errors when running this config
for the first time.
#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC
** Use-package installation
~use-package~ is used throughout the config to lazily load and configure
packages, as well as to ensure they are always installed.
*** Conditionally install use-package
The rest of the configuration will not work if ~use-package~ is not available,
the next piece of code ensures it's present.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC
*** Require use-package
The next line ensures there are no errors/warnings if byte-compiling the config
#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'use-package))
#+END_SRC
** Required packages
This are packages that come bundled with emacs, for packages downloaded from an
archive ~use-package~ is used.
#+BEGIN_SRC emacs-lisp
(require 'subr-x)
#+END_SRC
* General configuration
This is configuration that is not specific to a package
or is not big enough to merit its own headline at the
top level of the file.
** Spellcheck configuration
*** Flyspell configuration
For all text based modes have flyspell running.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook #'flyspell-mode)
#+END_SRC
For all programming modes having flyspell running would
cause a lot of visual clutter, this makes it only check
comments in code.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
#+END_SRC
*** Languages configuration
Create a ring to be cycled over by ~cycle-ispell-languages~.
#+begin_src emacs-lisp
  (let* ((user-ispell-languages (list "spanish" "english"))
	 (ring (make-ring (length user-ispell-languages))))
    (dolist (language user-ispell-languages) (ring-insert ring language))
    (defvar user-ispell-languages-ring ring "Languages used to cycle over in cycle-ispell-languages command"))
#+end_src
Cycle over the languages defined in ~user-ispell-languages-ring~ as ispell dictionaries.
#+begin_src emacs-lisp
  (defun cycle-ispell-languages ()
    (interactive)
    (let* ((language (ring-ref user-ispell-languages-ring -1)))
      (ring-insert user-ispell-languages-ring language)
      (ispell-change-dictionary language)))
#+end_src
Bind ~cycle-ispell-languages~ to a key.
#+begin_src emacs-lisp
  (global-set-key (kbd "<f6>") #'cycle-ispell-languages)
#+end_src
* Language server protocol configuration
** lsp-mode configuration
  Enable lsp-mode and ensure it's installed
  #+begin_src emacs-lisp
    (use-package lsp-mode
      :ensure t
      :hook
      ((lsp-mode . lsp-enable-which-key-integration)
       ((python-mode) . lsp))
      :commands lsp)
  #+end_src
** lsp-ui configuration
   Enable lsp-ui and ensure it's installed
   #+begin_src emacs-lisp
     (use-package lsp-ui
       :ensure t
       :commands lsp-ui-mode)
   #+end_src
** Ivy integration
   Add integration with ivy for lsp-mode
   #+begin_src emacs-lisp
     (use-package lsp-ivy
       :ensure t
       :commands lsp-ivy-workspace-symbol)
   #+end_src
** Performance
   The purpose of this part of the configuration is to improve the performance
   of lsp-mode as specified in the documentation for it.
*** Garbage collection
   ~gc-cons-threshold~ is too small for the needs of lsp-mode. Set it to a big
   number
   #+begin_src emacs-lisp
     (setq gc-cons-threshold 100000000)
   #+end_src
*** Read from process
    Language server responses can be very big, increase the amount of data emacs
    read from a subprocess.
    #+begin_src emacs-lisp
      (setq read-process-output-max (* 1024 1024))
    #+end_src
* Web configuration
** web-mode configuration
Ensure web-mode is installed and enable it for html files.
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (("\\.html?\\'" . web-mode)))
#+end_src
** js2-mode configuration
Ensure js2-mode is installed and enable it for javascript files.
#+begin_src emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode (("\\.js\\'" . js2-mode)))
#+end_src
** json-mode configuration
Ensure ~json-mode~ is installed, lazy load it for json files.
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (("\\.json\\'" . json-mode)))
#+end_src
* Lisp editing configuration
** Paredit configuration
Ensure paredit is installed and enable it for lisp related modes.
#+BEGIN_SRC emacs-lisp
  (use-package paredit-mode
     :ensure paredit
     :hook (emacs-lisp-mode lisp-mode racket-mode))
#+END_SRC
** Parinfer configuration
Parinfer is a package that makes it easier to edit lisp code
by infering indentation and parenthesis depth changes. Add a
binding for it and hooks for lisp modes.
#+BEGIN_SRC emacs-lisp
  (use-package parinfer-mode
    :ensure parinfer
    :disabled
    :bind (("C-," . parinfer-toggle-mode))
    :init
    (setq parinfer-extensions '(defaults
				 pretty-parens
				 smart-tab
				 smart-yank))
    :hook (emacs-lisp-mode lisp-mode))
#+END_SRC
** Racket configuration
Ensure ~racket-mode~ is installed and autoload it for .rkt files.
#+begin_src emacs-lisp
  (use-package racket-mode
    :ensure t
    :mode "\\.rkt\\'")
#+end_src
* Package configurations
** Markdown configuration
The only reason to have markdown configured is because it's more widespread
than org-mode for markup.
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode
    (("README\\.md\\'" . gfm-mode)
     ("\\.md\\'" . markdown-mode)
     ("\\.markdown\\'" . markdown-mode))
    :config
    (setq markdown-command "pandoc"))
#+END_SRC
** Rainbow delimiters
Add rainbow-delimiters and enable it for every programming related mode
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters-mode
    :ensure rainbow-delimiters
    :hook (prog-mode))
#+END_SRC
** All the icons
All the icons is a package used as dependency for other packages, it
guarantees its own space on the configuration.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :after all-the-icons-dired
    :ensure t)
#+END_SRC
** Dired configuration
*** All the icons in dired
Give dired some eye-candy by having icons next to file names.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :ensure t
  :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC
** Magit configuration
Magit is the one true way of interfacing with git. Lazily load
magit when pressing ~C-x g~.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC
** Git timemachine
Ensure ~git-timemachine~ is available and autoload for ~git-timemachine~
command.
#+begin_src emacs-lisp
  (use-package git-timemachine
    :ensure t
    :commands git-timemachine)
#+end_src
** Fish configuration
Enable fish-mode and load it for .fish files.
#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :ensure t
    :mode (("\\.fish\\'" . fish-mode)))
#+END_SRC
** Haskell configuration
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :mode "\\.hs\\'")
#+END_SRC
** Org configuration
*** Org mode configuration
Require the org package and make a binding for org-agenda to be callable,
also make a binding for ~org-capture~ and ~org-store-link~.
Ensure that .org files will be opened with org-mode. Set the location of
the agenda files to the value of the environment variable ~ORG_AGENDA~.
Set ~TODO~ and ~IN-PROGRESS~ as states, and ~DONE~, ~CANCELED~ and ~MISSED~
as the completed states for an agenda item; also give color to ~CANCELED~
and ~MISSED~ state.
Make the agenda buffer cover 14 days and make it start on the current day.
Enable ~org-crypt~ if the environment variable ~KEY_MAIL~ is set. This variable
is supposed to hold the email associated with a gpg key.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :bind (("C-c a" . org-agenda)
	   ("C-c c" . org-capture)
	   ("C-c l" . org-store-link))
    :mode (("\\.org\\'" . org-mode))
    :custom
    (org-agenda-span 14)
    (org-agenda-start-on-weekday nil)
    (org-adapt-indentation nil)
    (org-log-done 'time)
    (org-todo-keywords '((sequence "TODO(t)" "IN-PROGRESS(i)" "|" "DONE(d)" "CANCELED(c)" "MISSED(m)")))
    (org-todo-keyword-faces '(("CANCELED" . "magenta") ("MISSED" . "red")))
    :config
    (when-let* ((agenda-directory (getenv "ORG_AGENDA")))
      (setq org-agenda-files (directory-files-recursively agenda-directory "\\.org$")))
    (when-let* ((mail (getenv "KEY_MAIL")))
      (require 'org-crypt)
      (org-crypt-use-before-save-magic)
      (setq org-tags-exclude-from-inheritance (quote ("crypt"))
	    org-crypt-key mail
	    auto-save-default nil))
    (require 'org-habit))
#+END_SRC
*** Org journal configuration
Ensure org-journal is installed but only set it to be configured if the
environment variables ~ORG_JOURNAL~ and ~KEY_MAIL~ are set, we are only
interested in configuring this package if we have a journal folder and we can
encrypt it. Bind "C-c C-j" to new entry creation.
#+begin_src emacs-lisp
  (use-package org-journal
    :ensure t
    :if (getenv "ORG_JOURNAL")
    :if (getenv "KEY_MAIL")
    :bind (("C-c C-j" . org-journal-new-entry))
    :config
    (setq org-journal-dir (getenv "ORG_JOURNAL")
	  org-journal-enable-encryption t))
#+end_src
** Swiper configuration
Use swiper as a superior alternative to I-search. Bind it to 
~C-s~ to use it every time a search is performed in a buffer.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind (("\C-s" . swiper)))
#+END_SRC
** Counsel configuration
Require the counsel package and enable both counsel and ivy, the
latter comes bundled with counsel. For all searches performed with ivy enable
fuzzy matching.
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :config
    (ivy-mode 1)
    (counsel-mode 1)
    (setq ivy-re-builders-alist '((swiper . ivy--regex-plus)
				  (t . ivy--regex-fuzzy))))
#+END_SRC
** Multiple cursors configuration
Include the ~multiple-cursors~ package and add a key-binding for ~mc/edit-lines~
to ~C-c m c~ as a mnemonic for /multiple cursors/.
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind
    (("C-c m c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C-<" . mc/mark-all-like-this)))
#+END_SRC
** Flycheck configuration
Add flycheck package
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (global-flycheck-mode 1)
    :custom
    (flycheck-display-errors-delay 0.3))
#+end_src
** Which-key configuration
   Add which-key package
   #+begin_src emacs-lisp
     (use-package which-key
       :ensure t
       :config
       (which-key-mode 1)
       :custom
       (which-key-idle-delay 0.1))
   #+end_src
** Company configuration
   Configure company-mode. The main purpose of having this mode is for the CAPF
   back-end to be used with lsp-mode.
   #+begin_src emacs-lisp
     (use-package company
       :ensure t
       :custom
       (company-minimum-prefix-length 1)
       (company-idle-delay 0.0))
   #+end_src
** Projectile configuration
   Ensure projectile is installed and bind its keymap to ~C-c p~
   #+begin_src emacs-lisp
     (use-package projectile
       :ensure t
       :bind-keymap
       (("C-c p" . projectile-command-map))
       :config
       (projectile-mode 1))
   #+end_src
** Pipenv configuration
   Ensure ~pipenv.el~ is installed. Bind ~pipenv-activate~ to ~C-c C-p a~ with
   the purpose of setting virtualenv before starting editing a project using pyls.
   #+begin_src emacs-lisp
     (use-package pipenv
       :ensure t
       :bind
       (("C-c C-p a" . pipenv-activate)))
   #+end_src
* Usability configuration
** Clear screen
Remove menu bar, tool bar and scroll bar to have a clearer editing screen.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(toggle-scroll-bar -1)
#+END_SRC
** Mwim configuration
Ensure ~mwim~ package is installed. Bind its commands to move to the end and
beginning of line, as well as the ~mwim~ command to ~C-<tab>~ to switch between
positions in the line.
#+begin_src emacs-lisp
  (use-package mwim
    :ensure t
    :bind (("C-a" . mwim-beginning)
	   ("C-e" . mwim-end)
	   ("C-<tab>" . mwim)))
#+end_src
** Add line numbers
Use ~display-line-numbers-mode~ to give line numbers to emacs buffers
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
#+END_SRC
** Delete selection
Replace selected region when typing
#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src
** Parenthesis matching
Match parenthesis on every programming mode using ~electric-pair-mode~.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)
#+END_SRC
** Mac usability
Working on mac gets very awkward as the option key is used for META
making it unusable for the rest of uses that it has on mac. If for some reason
I am forced to work on a mac again make only command work as the META key.
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq ns-command-modifier 'meta
	ns-alternate-modifier nil))
#+END_SRC
** Font configuration
*** Safe set font
The following font serves to set the font without the program crashing
for not finding it
#+BEGIN_SRC emacs-lisp
(defun safe-set-font (font-name)
  "If the font exists set it to be used in all frames"
  (when (member font-name (font-family-list))
    (set-frame-font font-name t t)))
#+END_SRC
*** Set font
**** TODO Come up with a way to not have the font hard coded
The font used is hard coded to ~FuraCode~ from Nerd fonts.
#+BEGIN_SRC emacs-lisp
  (defvar font-name "FuraCode Nerd Font" "Font to be used by emacs")
  (safe-set-font font-name)
#+END_SRC
** Backup configuration
Set ~backup-directory-alist~ variable to prevent backups from being created into
the same directory as the original file and prevent clutter. Configure backup
related variables
#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.saves"))
	delete-old-versions t
	kept-new-versions 6
	kept-old-versions 2
	version-control t)
#+end_src
** Miscellaneous configuration
This section of the configuration pertains to small usability configuration
that is not big enough to have its own section on the usability section.
*** Symlinks configuration
Always follow symlinks when opening files
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC
*** Column size
Set the column size to 80 characters
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC
*** Limit VC
Only use VC for git.
#+BEGIN_SRC emacs-lisp
  (setq vc-handled-backends '(Git))
#+END_SRC
*** Enable auto-fill-mode
Enable auto-fill-mode for modes based on text-mode.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+END_SRC
*** Enable auto-revert-mode
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC
** Restart-emacs configuration
Ensure ~restart-emacs~ is installed. Lazy load the command to restart emacs and
bind it to ~C-M-q~.
#+begin_src emacs-lisp
  (use-package restart-emacs
    :ensure t
    :bind (("C-M-q" . restart-emacs)))
#+end_src
* Utility functions
** Reload configuration
Function used to reload the config file
#+BEGIN_SRC emacs-lisp
  (defun reload-config ()
     "Reload the configuration file"
     (interactive)
     (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC
** Open configuration
Make it easier to open the configuration file by just jumping to it with a
command.
#+begin_src emacs-lisp
  (defun open-config ()
    "Jump to the configuration file directly"
    (interactive)
    (find-file (expand-file-name "README.org" user-emacs-directory)))
#+end_src
